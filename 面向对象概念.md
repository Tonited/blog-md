---
titile: 面向对象概念
author: Roger S.Pressman & Bruce R.Maxim
date: 2020.06.08
keywords: 面向对象概念
img: https://img-blog.csdnimg.cn/20200608123744219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70
categories: 软件工程
tags: 软件工程：实践者的研究方法
---

﻿

# 概述

什么是面向对象（Object-Oriented，OO）观点？为什么一个方法被认 为是面向对象的？什么是对象？在20 世纪80 年代和90 年代，面向对象 概念赢得了广泛的传播，在那时，关于这些问题的答案有很多不同观点， 但是今天关于面向对象概念的一个统一观点已经形成。本文将提供这个重要课题的简要描述，并介绍基本概念和术语。 



为了理解面向对象的观点，首先考虑一个现实世界对象的例子——你 正在坐着的东西——一把椅子。Chair 类是更大的类PieceOfFurniture（家具）的子 类，椅子这一个体是Chair 类的成员（通常称为实例）。

可以将一组一般属 性关联到PieceOfFurniture 类的每个对象上。例如，在很多可能的属性中， 所有家具都有成本、尺寸、重量、位置和颜色。不管我们在讨论桌子还是 椅子、沙发还是衣橱，这些属性都适用。因为 Chair 是 PieceOfFurniture 的 一个成员，所以 Chair 继承了 PieceOfFurniture 类的所有属性。 



我们只通过描述类的属性来定义类，  但是这并不全面。

PieceOfFurniture 类的每个对象都可以通过很多方法进行操作。它可以被买卖，可以被物理地改变（例如，你可以锯掉它的一条腿或将它涂成紫色）， 也可以将它从一个地方移到另一个地方。

每个操作（其他术语为服务或方法）都会修改该对 象的一个或多个属性。

例如，如果位置属性为一个组合数据项，其定义如下： location = building + ﬂoor + room 

那么名为move() 的操作将会修改形成属性location 的一个或多个数据项（building、floor 或 room）。为此，move 必须具有这些数据项的“知识”。move() 操作可以用在椅子或桌子上， 只要它俩都是PieceOfFurniture 类的实例，PieceOfFurniture 的有效操作——buy()、sell()、 weigh()——被描述为类定义的一部分，并被类的所有实例继承。 



Chair 类（通常和所有对象）封装数据（定义椅子的属性值）、操作（改变椅子属性的动 作）、其他对象、常量（设值）和其他相关信息。封装意味着该信息的所有部分被打包在一个 名字下，并且可以作为一份规格说明或程序构件加以复用。 



现在我们已经介绍了一些基本概念，面向对象的更正式的定义会更有意义。Coad 和 Yourdon[Coa91] 是这样定义面向对象的： 

**`面向对象 = 对象 + 类 + 继承 + 通信 `**

其中的三个概念都已经介绍过了，通信概念将在本文的后面部分讨论。 



# 类和对象

类是面向对象的概念，它封装了描述现实世界实体的内容和行为所需要的数据抽象和过程抽象。

描述类的数据抽象被能以某种方式操作数据的过程抽象“墙”所围绕[Tay90]（如图 A2-1 所示）。

![图 A2-1 类的图解表示](https://img-blog.csdnimg.cn/20200608123744219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70)

在设计良好的类中，进入属性（和其上操作）的唯一途径是通过组成墙的方 法，如图中所示，因此，该类封装了数据（在墙里面）和操作数据的处理（组成墙的方法）。 这样做可以获得信息隐藏），并减少由变更引起的副作用。 



因为方法倾向于操作一组受限的属性，所以它们的内聚性得到了改进，并且因为通信仅 仅通过组成“墙”的方法才能进行，所以类趋向于减弱和系统其他元素的连接。

> 　 然而，值得注意的是，在面向对象系统中，耦合会成为一个严重的问题。当系统中不同部分的类用作属性的数据类型和方法的参数时，耦合就产生了。即使只能通过过程调用进入对象，也并不意味着耦合必然很低， 只不过比直接进入对象的程度低而已。



换种说法，类是一般化的描述（例如，模板或蓝图），它描述了相似对象的集合。

通过 定义，对象是特定类的实例并继承类的属性和控制属性的操作。

`超类`（通常称为基类）是 对与其关联的一组类的泛化。`子类`是超类的特殊化。

例如，超类MotorVehicle 是类Truck、 SUV、Automobile 和 Van 的泛化。子类Automobile 继承MotorVehicle 的所有属性，并且还 有特定于汽车的其他属性。 



这些定义意味着存在一种类的层次结构，在这种结构中，超类的属性和方法由子类继 承，每个子类又可以增加附加的“私有”属性和方法。例如，操作sitOn() 和 turn() 对于 Chair 子类是私有的。



# 属性

属性关联于类并以某种方式描述类。

属性可以具有由枚举`域`定义的数值。

在大多数情况下，域仅仅指的是是一组特定的值。

例如，假定Automobile 类有一个color 属性。color 的值域 为 {white，black，silver，gray，blue，red，yellow，green}。

在更复杂的情况下，域可能是一个类。

继续这个例子，Automobile 类还有一个powerTrain 属性，该属性本身就是一个类。 PowerTrain 类将包括描述车辆的特定发动机和变速器的属性。 



可以通过将缺省值（特征）赋给属性来扩大`特征`（值域）。例如，color 属性的缺省值为 white。

通过分配{ 值，概率 } 对，将某个概率与特定的特征联系起来也是有用的。考虑汽车的color 属性。在某些应用系统中（例如，制造计划），就有必要为每种颜色分配一个概率（例如，白色和黑色作为汽车颜色的概率非常高）。



# 操作、方法和服务

对象封装着数据（表示为属性的集合）和处理数据的算法。将这些算法称为`操作、方法 或服务`，并可以视为处理构件。



每个由对象封装的操作都提供了对象行为的一种表示。

例如，Automobile 对象的 GetColor() 操作可以取出存储在color 属性中的颜色。该操作的含义是：Automobile 类可接收一个刺激（我们称这个刺激为`消息`），该刺激请求类的特定实例的颜色。

只要对象收到该刺激，它就会初始化一些行为。这样的行为可以简单到检索汽车的颜色，也可以复杂到初始化连接大量不同对象的刺激链。



在后一种情况下，思考一个例子，由Object1 对象收到的初 始化刺激产生两个不同的刺激分别送往Object2 和 Object3。由第二个和第三个对象封装的操作作用于刺激，返回必要的信息到第一个对象。Object1 然后使用返回信息以满足初始化刺激所要求的行为。



# 面向对象分析和设计概念

## 需求建模

需求建模（也称分析建模）主要集中在由问题陈述中直接抽取的类上。这些`实体类`类通常 表示的是存储在数据库中并在应用程序持续的时间内一直存在的事物（除非特意将其删除）。

## 边界类和控制器类

设计改进和扩展了实体类的集合。边界类和控制器类在设计期间得到了开发和改进。

### 边界类

`边界类`创建用户可以看到的接口（例如，交互屏幕和输出报告），该接口可在使用软件时与用 户进行交互。设计边界类是为了管理实体对象显示给用户的方式。

### 控制器类

`控制器类`用来管理：

1. 实体对象的建立或更新；
2. 当边界对象从实体对象获取信息时边界对象的实例化；
3. 对象集合之间的复杂通信；
4. 对象之间或用户与应用系统之间通信数据的有效性。 



以下段落讨论的概念在分析和设计工作中十分有用。 

## 继承

继承是传统系统和面向对象系统之间的主要区别之一。子类Y 继承其超类X 的 所有属性和操作，这意味着原来为X 设计和实现的所有数据结构和算法都可以立即为Y 所 用——不需要做进一步的工作，重用可直接完成。 



超类的属性或操作的任何改变都可以立即被所有子类继承。因此，类的层次结构成为一 种机制，（在高层次上的）改变可以立即在系统中传播。 



值得注意的是，在类继承的各个层次上，对于那些继承自更高层次的类，还可以增加新的属性和操作。

实际上，每当创建一个新类时，你都可以有很多选择： 

- 可以从头开始设计和构建类，也就是说，可以不使用继承。
- 可以对类的层次结构进行查找，以确定在较高层次的类中是否包含了大多数需要的属性和操作。新类可以根据需要来继承较高层的类，然后进行增加。
- 可以对类的层次结构进行调整，使得所需要的属性和操作可以被新类继承。
- 已有类的特征可以被重写，对于新类，可以实现不同版本的属性或操作。

像所有基本的设计概念一样，继承可为设计带来显著好处。但是，若使用不恰当（例如，设计子类继承多个超类的属性和操作（有时称为“多重继承”）会让大多数设计者费解。），就会使设计呈现出不必要的复杂性，并导致难以维护和易于出错的软件。



## 消息

类之间必须彼此交互来完成设计目标。消息刺激接收对象产生某种行为，当操作执行时，完成该行为。 

![图 A2-2 对象之间的消息传递](https://img-blog.csdnimg.cn/20200608131009560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70)

对象之间的相互作用由图 A2-2 做了概要描述。

SenderObject 内的操作产生一条 message (< parameters >) 形 式 的 消 息， 其 中， 参 数（parameters）包含如下信息：

1.  消息刺激的对象ReceiverObject
2. 将要接收这条消息的 ReceiverObject 中的操作
3. 为使操作 获得成功需要提供信息的数据项。

所定义的类之间的协作是分析模型的一部分，在 消息设计中提供了十分有用的指导。 



Cox[Cox86] 以如下方式描述了类之间的交互：

1. 通过给对象（类）发送消息告诉对象做什么来要求其执行某个操作。
2. 接收者（对象）通 过选择对应消息名字的操作去执行，然后将控制权交还给调用者，从而响应消息。
3. 消息提供了单个对象和整体的面向对象系统行为的洞察力。 



## 多态

多态是一种特性，这种特性可以显著减少 扩展已存在的面向对象系统的设计 所需要的工作量。

为了理解多态，考虑一个传统的应用程序，此程序可绘制 4 种不同类型的图：线图、饼图、直方图和雷达图。理想情况下，只要针对某种特殊类型的图收集数据， 该图就可以自行绘制

要在传统程序中完成这项工作（并维护模块的内聚性），就有必要为每类图形都开发绘图模块。在设计中必须嵌入类似下面的控制逻辑： 

```
case of graphtype:
	if graphtype = linegraph then DrawLineGraph (data);
    if graphtype = piechart then DrawPieChart (data);
    if graphtype = histogram then DrawHisto (data);
    if graphtype = kiviat then DrawKiviat (data);
end case;
```

虽然设计很简单，但是添加新图类型会很棘手。要为每种图创建新的绘图模块，然后还要修改控制逻辑以反映新的绘图类型。



为了解决这个问题，所有图形都成为一般类Graph 的子类。使用重载的概念[Tay90]， 每个子类都定义 draw 操作。

一个对象可以发送一条draw 消息给由任意子类实例化的任意对 象。接收消息的对象将会调用它本身的 draw 操作去创建适当的图，因此，将设计精简为： draw < graphtype > 

当系统中增加一种新的画图类型时，就会创建一个带有它独有的draw 操作的子类。但是，在想要绘图的任何对象内不需要任何改变，因为消息draw〈 graphtype〉没有改变。



总之，多态能够使很多不同的操作拥有相同的名字。反过来也使对象之间彼此分离，使每个对象更加独立。 



## 设计类

需求模型定义了分析类的完整集合。每个分析类都描述了问题域的某种元素， 集中在用户或客户可见的问题方面。分析类的抽象等级相对比较高。



随着设计模型的进展，软件团队必须定义一组设计类：

1. 通过提供使类得以实现的设计细节对分析类进行细化；
2. 创建一组新的设计类实现支持业务解决方案的软件基础结构。



建议采用 5 种不同类型的设计类，每种设计类表示设计架构的下述不同层 [Amb01]：

- 用户界面类：定义所有人机交互（HCI）所必需的抽象。
- 业务域类：通常为早先定义的分析类的改进。类确定实现业务域的某些元素所需要的属性和服务（方法）。
- 处理类：执行需要管理业务域类的低层业务抽象。
- 持久类：表示持续时间超过软件执行时间的数据存储（如数据库）。
- 系统类：实现软件管理和控制功能，使系统能在内部计算环境和外部世界中操作和交流。 

随着体系结构设计的进展，软件团队应当为每个设计类开发出完整的一组属性和操作。 随着每个分析类转化为设计表示，抽象程度会降低。也就是说，分析类使用业务域术语表示对象（及应用于对象上的相关方法）。作为实现的指南，设计类在一定程度上给出了更多的 技术细节。 



Arlow 和 Neustadt[Arl02] 建议对每个设计类进行评审，以确保它是“组成良好”的。组 成良好的设计类的 4 个特征如下。 

- 完整性和充分性

  设计类应当完整地封装期望可能存在于类中的所有属性和方法（基于对类名的合理解释）。

  例如，对于为视频编辑软件定义的Scene 类，仅当它包括所有与创建视频场景有关的属性和方法时，才是完整的。

  充分性确保设计类仅包括那些能够完成类的意 图的方法，不会多也不会少。 

- 原始性

  与设计类有关的方法应集中在完成类的一个特定功能上。一旦该功能由一 个方法实现了，该类不应当再提供其他方法去完成同样的事情。

  例如，视频编辑软件的 VideoClip 类也许由start-point 和 end-point 属性来表明剪辑的开始点和结束点（注意，载入到系统中的未加工视频也许会比剪辑过的要长一些）。方法 setStartPoint() 和 setEndPoint() 提供了唯一的手段来建立剪辑的开始点和结束点。 

- 高内聚

  一个内聚的设计类是专一的。也就是说，它有一组小的、集中的责任，并专 一地应用属性和方法来完成这些责任。

  例如，视频编辑软件的VideoClip 类也许包括一套 方法用来编辑视频剪辑。只要每个方法单独集中于与视频剪辑有关的属性上，就维持了内聚性。 

- 低耦合

  在设计模型中，设计类彼此协作是有必要的。然而，协作应保持在一个可接受的最低限度。如果设计模型高度耦合（所有设计类都与所有的其他设计类协作），那么随着时间的推移，系统将很难实现、测试和维护。

  总之，在子系统中，设计类应该对其他类只有 有限的了解。这个限制称为Demeter 原则[Lie03]，建议一个方法应该只能给相邻类的方法发送消息。 

  > 　 叙述 Demeter 原则的一种不太正式的说法是“每个单元应当只与它的朋友交谈，不要与陌生人谈话”。