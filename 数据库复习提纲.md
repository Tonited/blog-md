---
titile: 数据库复习提纲
author: Tonited
date: 2019.10.12
keywords: 数据库复习提纲
img: https://img-blog.csdnimg.cn/20200217150856619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70
categories: 编程知识
---

## 概述

![](https://img-blog.csdnimg.cn/20200217150856619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70)

根据本年2019数据库复习要点整理，书籍为《数据库系统概论》（第五版，王珊、萨师煊）



## 第1章 绪论

### 1.数据库的四个基本概念（简述）

- 数据（data）：描述事物的符号记录
- 数据库（DataBase，DB）：长期存储在计算机内，有组织的、可共享的大量数据的集合。
- 数据库管理系统（DataBase Management，DBMS）：位于用户和操作系统中间的一层数据管理软件，科学高效的组织、存储、维护数据。
- 数据库系统（Database System , DBS）：由数据库、数据库管理系统、数据库管理员、应用程序组成的存储、管理、维护数据的系统

### 2.数据库管理系统的主要功能（简述）

- 数据的组织、存储、管理、维护

### 3.数据库技术的发展阶段（简述）

- 人工管理，文件系统，数据库系统

### 4.数据库系统的主要特点（简述）

- 数据结构化
- 数据共享性高，冗余度低，易扩充
- 数据独立性高
- 数据由DBMS统一管理和控制

### 5.数据模型的层次（简述）

- 第一层：概念模型，将现实世界抽象为信息世界
- 第二层：逻辑模型和物理模型，将信息世界抽象为机器世界

### 6.数据模型的组成要素（简述）

- 数据结构
- 数据操作
- 数据的完整性约束

### 7.信息世界中的基本概念（掌握）

- 实体（Entity）：客观存在并可以相互区别的“事物”
- 属性（Attributes）：实体的某一特性
- 实体集（Entity Set）：同型实体的集合称为实体集
- 键（Key）：能唯一标识一个实体的属性或属性集
- 联系（Relationship）：反应实体间的相互关系

### 8.实体间联系的类型（掌握）

- 一对一联系（1 : 1）
- 一对多联系（1 : n）
- 多对多（m : n）

### 9.ER模型（掌握）

- 参考[2019夏令营软件设计（一）：设计流程小结](https://blog.csdn.net/weixin_43553694/article/details/95758147)中第三步类设计的ER图

### 10.关系模型的数据结构及相关术语（理解）

- 关系模型数据结构：二维表 
- 相关术语：
  - 关系：就是二维表
  
  - 元组：表中的每一行数据，相当于一个记录值
  
  - 属性：表中每一列是一个属性值的集合
  
  - 码：表中用来唯一确定一个元组的一个属性或最小属性组
  
  - 域：属性的取值范围
  
  - 分量：元组中的一个属性值
  
  - 关系模式：对关系的描述，一般格式为
  
    ```sql
    关系名(属性1, 属性2, 属性3, ···)
    
    例如：
    学生(学号, 姓名, 年龄, 性别, 年级, 专业)
    ```
  
    

### 11.关系模型的优缺点（简述）

- 优点：
  - 建立在严格的数学概念基础上
  - 概念单一
  - 存储路径对用户透明，所以数据独立性更高、安全保密性更好、简化了程序员的工作和数据库开发建立
- 缺点：
  - 查询效率较低
  - DBMS需要对用户查询进行优化，增加了开发DBMS的难度

### 12.数据库系统的三级模式结构（理解、简述）

- 模式（逻辑模式、概念模式）：全体数据的逻辑结构和特征描述
- 外模式（用户模式）：数据库用户能看到的局部数据的逻辑结构和特征描述
- 内模式（存储模式）：数据物理结构和存储方式的描述

### 13.数据库的二级映像与数据独立性（理解、简述）

- 外模式 / 模式映像：对于每一个外模式，数据库系统都有一个外模式／模式映像，它定义了该外模式与模式之间的对应关系，保证了数据与程序的逻辑独立性。

- 模式 / 内模式映像：定义了数据库的全局逻辑结构与存储结构之间的对应关系，保证了数据与程序的物理独立性。



## 第2章 关系数据库

### 1.关系数据结构的形式化定义（掌握）

- 关系模型的数据结构——关系，是一张扁平的二维表

- 域：一组有相同数据类型的值的集合

- 笛卡尔积

  - 理解：两个关系做笛卡尔积，就是两个表`R1`和`R2`，`R1`中的每一条数据与`R2`中的每一条数据组合，形成的新的表就是笛卡尔积的结果

  - 举例

    ![](https://img-blog.csdnimg.cn/20200217150922650.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70)

- 关系：`D1xD2x...xDn`的子集叫做叫做在域`D1,D2,...,Dn`上的关系，表示为`R(D1,D2,...,Dn)`
  
  - R表示关系的名字，n是关系的目或度(degree)。

### 2.关系数据语言的分类（简述）

- 关系代数：用对关系的运算来表达查询要求。
- 关系演算：用谓词来表达查询要求。
- SQL：是集查询、数据定义语言、数据操纵语言、和数据控制语言于一体的关系数据语言，是一种高度非过程化的语言。

### 3.关系的完整性（理解、简述）

- 关系模型的完整性规则是对关系的某种约束条件
  - 实体完整性：主属性不能为空值
  - 参照完整性：设*F*是基本关系*R*的非码属性，*K*是关系*S*的主码，如果*F*和*K*相对应，那么*F*是关系*R*的外码
  - 用户自定义完整性：用户可以根据实际状况自定义约束条件

### 4.关系代数（掌握运用）

|       名称       | 符号 |                  说明                  |
| :--------------: | :--: | :------------------------------------: |
|       选择       |  σ   |         类似于 SQL 中的 where          |
|       投影       |  Π   |         类似于 SQL 中的 select         |
|        并        |  ∪   |         类似于 SQL 中的 union          |
|  集合交（附加）  |  ∩   |         SQL中没有对应的操作符          |
|      集合差      |  -   |         SQL中没有对应的操作符          |
| 自然连接（附加） |  ⋈   |       类似于 SQL 中的 inner join       |
|     笛卡尔积     |  ×   | 类似于 SQL 中不带 on 条件的 inner join |



## 第3章 关系数据库语言

### 1.SQL的基本概念（简述）

- 是一种特定目的程序语言，用于管理关系数据库管理系统，或在关系流数据管理系统中进行流处理。

- SQL基于关系代数和元组关系演算，SQL的范围包括数据插入、查询、更新和删除，数据库模式创建和修改，以及数据访问控制

### 2.基本表的定义（掌握）

- 格式

  ```sql
      CREATE TABLE <表名>（
          <列名>  <数据类型>  [列级完整性约束条件]，
          <列名>  <数据类型>  [列级完整性约束条件]，
          ...
          [表级完整性约束条件]
  ）；
  ```

- 举例

  ```sql
  CREATE TABLE Nation(/*国家表*/
    nationkey INTEGER PRIMARY KEY,                    /*国家编号*/
    name CHAR(25),                                    /*国家名称*/
    regionkey INTEGER REFERENCES Region(regionkey),   /*地区编号*/
    comment VARCHAR(152)                              /*备注*/
  );
  ```

### 3.索引的定义（掌握）

- 格式

  ```sql
  CREATE INDEX <索引名>
  ON <表名> ( <列名> );
  ```

- 举例

  ```sql
  /*本例会创建一个简单的索引，名为 "PersonIndex"，在 Person 表的 LastName 列：*/
  CREATE INDEX PersonIndex
  ON Person (LastName) ;
  ```

### 4.数据查询(掌握)

- 格式

  ```sql
  select <列名>
  from <表名>
  where <条件>;
  ```

- 举例

  ```sql
  /*--查询年龄在20-23之间的学生姓名、系别和年龄*/
  SELECT SNAME,SDEPT,AGE FROM S WHERE AGE BETWEEN 20 and 23;
  ```

### 5.数据更新（掌握）

- 格式

  ```sql
  UPDATE <表名> SET <列名> = <新值> WHERE <列名> = <某值>;
  ```

- 举例

  ```sql
  UPDATE Person SET Address = 'Zhongshan 23', City = 'Nanjing'
  WHERE LastName = 'Wilson';
  ```

### 6.空值处理（掌握）

- IS NULL

  ```sql
  SELECT LastName,FirstName,Address FROM Persons
  WHERE Address IS NULL;
  ```

- IS NOT NULL

  ```sql
  SELECT LastName,FirstName,Address FROM Persons
  WHERE Address IS NOT NULL;
  ```

### 7.视图的定义、查询、更新（掌握）

- 定义

  ```sql
  CREATE VIEW <视图名>
  AS <子查询>
  [ WITH CHECK OPTION ];
  ```

- 查询、更新

  与表的查询更新相同，只是把表名换成视图名



## 第4章 数据库安全性

### 1.实现数据库安全控制的技术（简述）

- 用户标志与鉴别

  系统提供一定的方式让用户标识自己的名字或身份，每次用户进入系统之前，核对用户标志

- 存取控制

  对不同人员定义不同的存取权限，用户访问时做权限检查

- 视图机制

  为不同的用户定义视图，把要保密的数据对无权存取的用户隐藏起来

- 审计

  把用户对数据库的所有操作自动记录下来放入审计日志中

- 数据加密

  对存储和传输的数据进行加密处理

### 2.常用的存取控制方法（分类简述）

- 自主存取控制：用户对不同的数据库对象有不同的存取权限，不同的用户对同一对象也有也有不同的权限，用户还可以将存取权限转授给其他用户

- 强制存取控制：每个数据库对象被标记一个密级，每个用户被授予某一级别的许可证。对任意一个对象只有合法许可证的用户才可以存取

### 3.数据库的用户和角色（掌握）

- 数据库用户：使用和共享数据库资源的人

- 数据库角色：是被命名的一组数据库操作权限，角色是权限的集合



### 4.权限管理（掌握）

- 用户权限管理
  - GRANT授予权限

    ```sql
    GRANT <权限> [,<权限> ,···]
    ON <对象类型> <对象名> [,<对象类型> <对象名> ,···]
    TO <用户> [,<用户> ,···]
    [WITH GRANT OPTION];
    /*WITH ADMIN OPTION使用户可以将获得的权限转授*/
    ```

  - REVOKE回收权限

    ```sql
    REVOKE <权限> [,<权限> ,···]
    ON <对象类型> <对象名> [,<对象类型> <对象名> ,···]
    FROM <用户> [,<用户> ,···] [CASCADE|RESTRICT];
    /*RESTRICT保持转授权限*/
    /*CASCADE级联回收权限 默认*/
    ```

  - 创建数据库模式的权限

    ```SQL
    CREATE USER <username> [WITH][DBA|RESOURCE|CONNECT]
    ```

    - 只有系统的超级用户才有权创建一个新的数据库用户
    - 数据库的三种权限
      - CONNECT权限：默认，只能登陆数据库
      - RESOURCE权限：只能创建基本表和视图，作为数据库对象的属主时可以授予其他用户该数据库对象的存取权限
      - DBA权限：创建用户、模式、基本表、视图，可以授予其他用户某数据库对象的存取权限

- 角色权限管理

  - 角色的创建

    ```sql
    CREATE ROLE <角色名>;
    ```

  - 给角色授权

    ```SQL
    GRANT <权限> [,<权限> ,···]
    ON <对象类型> 对象名
    TO <角色> [,<角色> ,···];
    ```

  - 将一个角色授予其他角色或用户

    ```sql
    GRANT <角色1> [,<角色2> ,···]
    TO <角色3> [,<角色4> ,···]
    [WITH ADMIN OPTION];
    ```

  - 角色权限收回

    ```sql
    REVOKE <权限> [,<权限> ,···]
    ON <对象类型> <对象名>
    FROM <角色> [,<角色> ,···];
    ```

### 5.视图机制（掌握）

- 为不同用户定义不同视图，把数据对象限制在一定的范围内

- 操作

  - 创建视图

    ```sql
    CREATE VIEW <视图名>
    AS <查询语句>;
    ```

    - 举例

      ```sql
      CREATE VIEW CS_Student
      AS
      SLELCT *
      FROM Student
      WHERE Sdept='CS';
      ```

  - 视图权限授予用户

    ```sql
    GRANT <权限>
    ON <视图名>
    TO <用户>;
    ```

    - 举例

      ```sql
      GRANT SELECT /*授予王平在视图上的查询权限*/
      ON CS_Student
      TO 王平;
      
      GRANT ALL PRIVILEGES /*授张明在视图上予所有权限*/
      ON CS_Student
      TO 张明;
      ```



## 第5章 数据库完整性（掌握）

### 1.实体完整性的定义

- 指数据的正确性（correctness）和兼容性（compat-ability）
  - 正确性：数据符合现实世界语义、反应实际情况
  - 兼容性：数据库同一对象在不同关系表中的数据是符合逻辑的

### 2.参照完整性的定义

- 指参照关系中外码的取值或者是空值或者是取被参照关系中某个元组的主码值

### 3.用户定义完整性的定义

- 针对某一具体应用的数据必须满足的语义要求

### 4.触发器的定义

- 用户定义在关系表上的一类由事件驱动的特殊过程



## 第6章 关系模式的规范化

### 1.函数依赖的定义和分类（掌握）

- 定义：设`R(U)`是属性集`U`上的关系模式，`x`，`Y`是`U`的子集，。若对于`R(U)`的任意一个可能的关系`r`，`r`中不可能存在两个元组在`X`上的属性值相等，而在`Y`的属性值上不等，则称**X函数确定Y，或Y函数依赖于X**，记作`X->Y`

  - 理解：一句话简单概括就是X的值确定下来之后，就能确定唯一的Y值

- 分类：

  - 完全函数依赖：在`R(U)`中，如果`X->Y`，并且对于`X`的任何一个真子集`X'`，都有`X'不能确定Y`
    
    - 理解：如果`X`由多个属性组成，所有属性一起才能确定唯一的`Y`值，其中的任何属性组合都不能确定唯一的`Y`值
  - 部分函数依赖：若`X->Y`，但`Y`不完全函数依赖于`X`，则称`Y`对`X`部分函数依赖，用箭头上带个p表示
  
    - 理解：如果`X`由多个属性组成，所有属性一起能确定唯一的`Y`值，其中的某属性或某些属性组合都也能确定唯一的`Y`值
  
  - 传递函数依赖：若在`R(U)`中，`X->Y`，`Y`不是`X`的子集，`X`不依赖`Y`，`Y->Z`，`Z`不是`Y`的子集，则称`Z`对`X`传递依赖，记号为箭头上方标记"传递"二字

    - 举例
  
      ```xml
      Sno->Sdept, Sdept->Mname成立， 所以Mname对Sno传递依赖
      ```

### 2.码（掌握）

- 定义：设`K`为`R<U,F>`中的属性或属性组合，若`K`能唯一确定`R`中的每一条元组，则`K`称为`R`的候选码

### 3.各类范式的含义和判断（掌握）

- 1NF

  - 理解：不能表中套表，例如不可出现以下情况

    ![](https://img-blog.csdnimg.cn/20200403154428388.png)

- 2NF

  - 定义：若`R∈1NF`，且每一个非主属性完全依赖于任何一个候选码，则`R∈2NF`

  - 理解：若码由多个属性组成，只有码中所有属性一起才能确定其他任何属性的唯一值，码中的任何一个属性或几个属性的组合都不能确定其他任何属性的唯一值

    

  - 举例：

    ```sql
    有关系SLC(Sno, Sdept, Sloc, Cno, Grade)
    若SLC的码为（Sno， Cno）
    如果出现满足函数依赖
    Sno->Sdept
    则不满足2NF，必须是码的所有属性(Sno, Cno)->Sdept才可以
    ```

  - 实质：消除部份依赖

- 3NF

  - 定义：设关系模式`R<U,F>∈1NF`，若`R`中不存在这样的码`X`：属性组`Y`及非主属性`Z(Z不属于Y)`，使得`X->Y, Y->Z`成立，且`X`不依赖于`Y`，则称`R<U,F>∈3NF`
  - 理解：不会出现属性传递依赖于码

  - 举例：

    ```sql
    有关系SLC(Sno, Sdept, Sloc, Cno, Grade)
    SLC的码为Sno
    若出现Sno->Sloc, Sloc->Grade
    则不满足3NF
    ```

  - 实质：消除传递依赖
  - 意义[^1]： 比如说操作记录表中，需要保存操作人ID，而页面需要显示操作人名称。第三范式要求只能存操作人ID，所以名称需要关联查询。

- BCNF
  - 注意：一般认为满足`BCNF`就满足`3NF`，但是`BCNF`不等于`3NF`，也称`BCNF`范式为扩充的`3NF`、修正的`3NF`
  - 定义：关系模式`R<U,F>∈1NF`，若`X->Y`且`Y`不属于`X`时`X`必含有码，则`R<U,F>∈BCNF`
  - 理解：非主键字段必须依赖于整个主键字！
  	- 也就是说，要想达到BCNF的标准，还要在3NF的基础上基础拆分表。如果你不是做高层次开发的，研究数据库的，还有4NF，5NF之类的东西，根本就极少用到，没有研究的必要的，相对而言，学术意义更多一些。 

### 4.函数依赖的逻辑蕴含（初步理解）

- 存在依赖集合`F`，通过`F`能推出原不直观存在于`F` 中的函数依赖 `α → β,`则称`α→β`被函数依赖集F逻辑蕴含

### 5.Armstrong公理系统（简述）

- 从已知的一些函数依赖可以推导出另一些函数依赖的推导规则

- 自反率

  ```sql
  在关系R中存在属性集X，Y
  若Y含于X
  则X->Y，即大推小
  ```

- 增广率： 若α-->β,则αω-->βω，即加了也不影响

- 传递率：α-->β,β-->ω,则α-->ω

- 推广-合并率：α-->β,α-->ω,则α-->βω，即合并右边

- 推广-分解率：α-->βω,则α-->ω,α-->β，即分解右边

- 伪传递律：α-->β,βπ-->ω则απ-->ω，即左边加一点

### 6.属性集的闭包

- 设`F`为属性集`U`上的一组函数依赖，`X、Y属于U`，`Xf+={A|X->A能由F根据Armstrong公理导出}`，则称`Xf+`为属性集`X`关于函数依赖集`F`的闭包

- 理解：对于属性集`X`，所有能由依赖集`F`推导出的、依赖于`X`的、属性的集合，称为属性集`X`关于函数依赖集`F`的闭包

### 7.属性依赖集的极小覆盖

- 定义：如果函数依赖集满足下列条件，则称`F`为一个极小函数依赖集，亦称为最小依赖集或最小覆盖
  - `F`中任何一个函数依赖右部仅含有一个属性
  - `F`中不存在这样的函数依赖`X->A`，使得`F`与`F-{X->A}`等价
  - `F`中不存在这样的函数依赖`X->A`,`X`有真子集`Z`使得`F-{X->A}∪{Z->A}`与`F`等价
- 理解：个人理解就是最小依赖集，就是指`F`中的依赖是最小的依赖集合，所有的其他依赖都靠最小依赖集推导出来，*最小依赖集内部的任何依赖*不能通过*最小依赖集内部的其他依赖*，理解起来有点像平面直角坐标系里x轴和y轴上的单位向量



## 第7章 数据库设计

### 1.数据库设计的基本步骤和各个步骤的主要任务（简述）

- 需求分析：分析用户需求
- 概念结构设计：归纳抽象总结用户需求，设计DBMS的概念模型
- 逻辑结构设计：将概念模型转换为某DBMS所支持的数据模型，并对其优化
- 物理结构设计：为逻辑数据模型选取一个最适合应用环境的物理结构
- 数据库实施：根据设计结果建立数据库，编写调试应用程序，数据组织入库，进行试运行
- 数据库运行和维护：正式投入使用，运行过程中不断对其评估调整修改

### 2.ER图向关系模型的转换（掌握）

- 一个`1:1`联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并
- 一个`1:n`联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并
- 一个`m:n`联系可以转换为一个关系模式
- 三个或三个以上的实体间的一个多元联系可以转换为一个关系模式
- 具有相同码的关系可以合并



## 第10章 事务管理

### 1.事务的含义（简述）

- 是用户定义的一系列数据库操作按一定顺序的组合，这些操作要么全做，要么全不做，是一个不可分割工作单位

### 2.事务ACID特性（简述）

- 原子性（**A**tomicity）：事务中的操作要么全做，要么全不做
- 一致性（**C**onsistency）：事务的执行结果必须是使数据库从一个一致性状态变到另一个一致性状态
  - （数据库只包含成功事务提交的结果就说数据库处于一致性状态。如果数据库系统运行中出现问题，有些事务尚未完成就被迫中断，这些未完成的事务对数据库所作的修改一部分已经写入物理数据库，这时数据库就处于一种不正确的状态，叫不一致状态）
- 隔离性（**I**solation）：一个事务的执行不能被其他事务干扰
- 持续性（**D**urability）：一个事物一旦被提交，它对数据库中数据的改变应该是永久的

### 3.并发控制操作带来的问题（简述）

- 丢失数据（lost update）：两个事务同时读入统一数据并修改，由于提交时间不同，导致后提交的破坏了先提交的数据

  ![](https://img-blog.csdnimg.cn/20200217151010264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70)

- 不可重复读（non-repeatable）：一个事务`T1`中有两个读数据操作，`T1`的第一个读操作做完、第二个个读操作还未开始时，另一个事务`T2`对该数据进行了修改|添加|删除，导致`T1`第二次读操作进行时发现数据不一致

  ![](https://img-blog.csdnimg.cn/20200217151020577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70)

- 脏读（dirty read）：事务`T1`中先对数据进行了修改，在`T1`执行之后的操作过程中，`T2`对其进行读取，但是`T1`在执行`T2`读取完之后的某一操作中发生故障，`T1`事务回滚到未执行阶段，数据被恢复成未执行阶段，但`T2`已经读取了被修改过的数据，导致`T2`读取到的数据与当前数据库中的数据不一致

  ![](https://img-blog.csdnimg.cn/20200217151025365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70)

### 4.可串行调度（简述）

- 事务并发调度的执行结果与某一串行调度的执行结果等价的调度

### 5.冲突可串行化调度（简述）

- 冲突操作：不同事务对同一个数据的读写操作和写写操作

- 冲突可串行化调度：如果一个调度`Sc`在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度`Sc'`，如果`Sc'`是串行的，则称调度`Sc`是冲突可串行化的调度

  ![](https://img-blog.csdnimg.cn/20200217151036947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70)

  - 实例：

    ![](https://img-blog.csdnimg.cn/20200217151042935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70)

  （图源来自[这篇博客](https://blog.csdn.net/J080624/article/details/84946940)）

### 6.并发控制的主要技术（简述）

- 封锁（locking）
- 时间戳（timestamp ）
- 乐观控制法（optimistic schedule）

- 多版本并发控制（multi-version concurrency control，MVCC）

### 7.封锁的基本类型和封锁的粒度（简述）

- 封锁的基本类型
  - 排他锁（exclusive locks，简称X锁）：又称写锁，当事务`T`对对象`A`加上`X锁`时，只允许`T`读取和修改`A`，这时其他任何事务都不能在`A`上添加任何的锁
  - 共享锁（share locks，简称S锁）：又称读锁，当事务`T`对对象`A`加上`S锁`时，`T`可以读取`A`但不能修改`A`，其他事务在`A`上只能加`S锁`，不能加`X锁`

- 封锁的粒度：指封锁对象的大小

### 8.活锁和死锁（简述）

- 活锁：事务`T1`封锁了数据`R`，事务`T2`发出封锁`R`的请求，在这个过程中有其他事务`T3`请求封锁`R`，系统优先将锁判给`T3`，于是当`T1`释放锁时`T3`先拿到锁，`T2`只能继续等待，这时其他事务继续请求封锁`R`，重复上述过程，`T2`只能无限等待，这就是活锁现象
  - 理解：可以理解成你去排队买冰激凌，所有新来的人都插队到你的前面，你就要一直等待

- 死锁：事务`T1`封锁对象`R1`，事务`T2`封锁对象`R2`，然后`T1`请求`R2`、`T2`请求`R1`，但是`R1`和`R2`正被锁住，所以`T1`等着`T2`释放`R2`、`T2`等着`T1`释放`R1`，只能无限的等下去
  - 理解：书上的一句解释很好——中国人对美国人说“你先给我筷子我再给你叉子”，美国人对中国人说“你先给我叉子我在给你筷子”

### 9.故障的种类（简述）

- 事务内部的故障
- 系统故障：也叫软故障，指造成系统停止运转的任何事件
- 介质故障：也叫硬故障，指物理性故障（如：磁盘损坏、磁场干扰等）
- 计算机病毒

### 10.数据库恢复的基本原理和具体实现方法（简述）

- 原理：建立冗余数据，并以这些冗余数据恢复数据库
- 方法
  - 数据转储：定期的将整个数据库复制到磁带、磁盘或其他存储介质上，数据库遭到破坏后将该后备副本重装
  - 登记日志文件：创建日志文档，用来记录事务对数据库的更新操作，数据库出现故障时根据日志重新执行操作

### 11.登记日志文件（掌握）

- 日志文件格式

  - 以记录为单位的日志文件，内容为

    - 各个事务的开始（BEGIN TRANSACTION）标记
    - 各个事务的结束（COMMIT或ROLLBACK）标记
    - 各个事务的所有更新操作

    - 上述的每一条称为一条记录日志，内容为：
      - 事务标志（标明是哪个事务）
      - 操作的类型（插入、删除、修改）
      - 操作对象（记录内部标志）
      - 更新前数据的旧值（插入操作时此项为空）
      - 更新后数据的新值（删除操作时此值为空）

  - 以数据块为单位的日志文件，内容为

    - 事务标志
    - 被更新的数据块

    - （由于更新前后的整个块都放到了日志文件中，操作类型、操作对象等信息就不用放到记录中了）

- 日志文件的作用

  - 事务故障恢复必须用日志文件
  - 动态转储方式中必须建立日志文件，后被副本和日志文件结合起来才能有效的恢复数据库
  - 静态转储方式也可以建立日志文件，当数据库毁坏时可以先通过后援副本重装将数据库恢复到转储时的状态，再通过日志文件把之前执行过的事务重新执行，撤销故障时尚未完成的事务



## 必考点
- ER图
- 函数依赖
- 关系代数
- SQL 语言

<hr/>
[^1]:本处参考：https://www.oschina.net/question/1586247_2200027?sort=default

感谢LYC的提问 使本文更加完善