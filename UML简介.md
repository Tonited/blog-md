---
titile: UML简介
author: Dale Skrien
date: 2020.05.31
keywords: UML简介
img: https://img-blog.csdnimg.cn/20200531143505991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70
categories: 软件工程
tags: 软件工程：实践者的研究方法
---

﻿

# 简介

统一建模语言（Unified Modeling Language，UML）是“绘制软件蓝图的标准化语言。
UML 用来可视化、描述、构造和文档化软件密集系统的 人工制品”[Boo05]。
如果了 解 UML 的词汇（图示元素和它们的含义），就可以很轻松地理解和描述一 个系统，并向他人解释该系统的设计。 

Grady Booch、Jim Rumbaugh 和 Ivar Jackson 在 20 世纪90 年代中期 开发出了UML 语言。
目前的标准是 UML 2.3 ，也是 ISO 标准。因为这个标准很新，所以很多旧的资料，（如[Gam95]）都没有 使用 UML 符号。 

UML 2.3 提供了13 种不同的图以供软件建模使用。在本文中，将 仅讨论类图、部署图、用例图、顺序图、通信图、活动图和状态图。

应该注意，UML 图有很多可选功能。UML 语言提供了这些选项（有时候是隐藏的）， 使得软件工程师能表达系统的所有重要方面。同时，还可以灵活地隐藏图中那些与建模无关的部分，避免无关的细节将图弄得杂乱。
因此，一种特殊功能的省略并不意味着该功能的缺 失，它可能意味着该功能被隐藏了。

在本文中，没有介绍UML 图的所有功能，而是重点介绍标准选项

# 类图
为了对类建模（包括类的属性、操作和关系以及和其他类的联系）， UML 提供了类图， 类图提供了系统的静态或结构视图。它并不显示图中类的对象之间通信的动态特性。 

## 表示
类图的主要元素是方框，方框是一些用来描述类和接口的图符。

### 三部分
每个方框都被水平地划分为多个部分。
- 顶层部分包含类的名字
- 中间部分列出了类的属性
	属性可以是一些数值，这些数值是由类从它的实例变量中计算出来的，或是从组成它的其他对象中得到的。
	> 比如， 对象可以时刻知道当前时间，在这种情况下，适合把时间作为属性，因为可以在getter中经过计算获取。如果将时间存在实例变量中，那么这个时间就是死的。
	
	> 实例变量和属性：简单解释，实例对象是写在类内方法外的变量，属性是有getter和setter的实例变量
	
- 第三部分包含类的操作或行为。
	操作是指类的对象所能做的事情，通常实现为类的方法。

![图 A1-1 Thoroughbread 类的类图](https://img-blog.csdnimg.cn/20200531142102966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70)
图 A1-1 介绍了一个简单例子，用Thoroughbred（纯种） 类对优良种马建模。
它有三个属性——mother、father 和 birthyear
还有三个操作—— getCurrentAge()、getFather() 和 getMother()。
图中也有 一些隐藏的属性和操作没有显示。

### 修饰
每个属性都有名字、类型和可见性级别。类型和可见性都是可选的。
类型放在名字后面，并用冒号进行分隔。
可见性由前面的－、#、~ 或＋指定，分别代表私有、 受保护、包或公有可见性。

> 在图A1-1 中，所有属性都是 私有的，由前面的减号（－）指出。

下划线表示属性是否为静态属性或类属性，
可以用可见性级别、带名字和类型的参数以及返回类型来表示每个操作。 

在类图中，名字设成斜体表示抽象的类或方法。例如，图A1-2 中的Horse 类就是抽 象类。
通过在名字的上方添加短语“interface”（称为构造型）来指定接口，如图A1-2 中的 OwnedObject 接口。也可以用空心圆来表示接口。

 ![图 A1-2 有关马的类图](https://img-blog.csdnimg.cn/20200531143505991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70)值得一提的是，表示类的图符可以有其他可选的部分。例如，处于类方框底层的第四部分可以列出类的责任。
> 在产生属性和操作之前，CRC 卡片上列出的责任如能添加在 UML 图 中类方框的第四部分，则这一部分在CRC 卡片（第 9 章）向类图转换时特别有用。本文中的所有图均未显示第四部分。 


## 表示类之间的关系
### 泛化
类和它的子类之间用实线加上空心的三角箭头连接。箭头的方向是从子类指向父类。
在UML 中，这样的关系称为泛化。

比如，在图A1-2 中，类Thoroughbred 和类QuarterHorse 显示为Horse 抽象类的子类

### 实现

带虚线的箭头表示接口的实 现。在 UML 中，这样的关系称为实现。
例如，图A1-2 中，Horse 类实现了OwnedObject 接口。 


### 关联
两个类之间的关联是指它们之间存在着结构上的关系。
关联用实线表示，有很多可选部分。

可以在它的每一端都加上标签，指定关联中每个类的角色。
例如，在图A1-2 中，OwnedObject 和 Person 之间存在关联，Person 在此关联中扮演所有者（owner）的角色
![图 A1-2 有关马的类图](https://img-blog.csdnimg.cn/20200531143505991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70)关联也可以通过循环连接它本身，这样的关联表明同 一类所创建的不同对象之间可以相互连接。 

#### 导航性
关联线一端或两端的箭头表示可导航性。

一端带箭头的关联表明这是一个单向导航。箭头表明从第一个类可以很容易访问关联方 向所指的第二个类，但是从第二个类却不能很容易地访问第一个类。
关于这种现象的另外 一种解释是，第一个类可以察觉到第二个类，但是第二个类的对象将不能直接察觉到第一个类。

没有箭头的关联通常表明它是一个双向的关联，这就是图A1-2 中所指的。也有可能是仅仅意味着可导航性并不重要，所以省略了。 

应当注意到，一个类的某个属性和类（其属性所属的类型是类）的关联是一样的。

> 就是说，想表达类中有叫作“name”的String 类型的特性，那就直接在类中写（如图 A1-2 Horse类中name属性的写法）。或者，也可以构建一个从Horse 类到 String 类的单向关联，在此关联中，String 类的角色是“name”。

对于原始数据类型，用属性的办法会更好些，而当特性类在设计中起重要作用时，用关联的方法通常比较好一些，在那种情况下，有那种类型的类方框更有价值。 

#### 依赖关系
依赖关系表示类之间的另一种连接，由一条虚线（可选的段末箭头和可选的标签）表示。 

一个类依赖于另一个类，则改变另一个类也需要改变这个类。从一个类到另一个类的关联就自动表明了一种依赖性。如果类之间已存在关联则不需要虚线。

然而，对于短暂的关系（即 一个类不需要同另一个类维持长时间的连接，但确实偶尔会用到另一个类），我们应该从第 一个类画一条虚线到第二个类。
> 例如，在图A1-2 中，当 Thoroughbred 类的getCurrentAge() 方法被调用时，它需要使用 Date 类，所以依赖性被标识为“uses”。 

![图 A1-2 有关马的类图](https://img-blog.csdnimg.cn/20200531143505991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70)
#### 多重性
关联一端的多重性是指类关联于其他类的对象的数量。多重性由非负整数或整数范围描述。

- 通过“0..1”描述的多重性是指在关联的一端存在 0 或 1 个对象。
	例如，世界上的每个人要么有社会保险号，要么没有，因此，多重性0..1 就可以在类图中的Person 类 和 SocialSecurityNumber 类之间的关联中使用。
- 由“1..*”描述的多重性是指一个或更多
- 由“0..*”或者只是一个“星”描述的多重性指的是 0 个或更多。 在图A1-2 中，与 Person 类关联的 OwnedObject 端的多重性使用了一个”星“，因为 Person 可以拥有 0 个或更多的对象。

如果关联的一端有比 1 大的多重性，那么该端涉及的对象将可能被存储于收集中，如集合或有序列表。在UML 图中，也可以包括收集类本身，但是，由于关联的多重性，这样的类通常被省略并假定存在那里。 

### 聚合和组合
聚合是一种特殊的关联，通过图符一端的空心钻石表示。它表明一种“整体/ 部分”关 系，箭头所指的类是关联的菱形端的一“部分”。

组合表明聚合对部分的强所有权。在组合 中，部分随着所有者而生存或消亡，因为它们在独立于所有者的软件系统中没有作用。

参见 图 A1-3 中关于聚合和组合的例子。 

![图 A1-3 College、Course和Building之间的关系](https://img-blog.csdnimg.cn/20200531150658183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70)College 有一个包含Building 对象的聚合，这表示建筑构成了学院。学院也有一个包含课程的集合。
如果学院倒闭了，建筑仍将存在（假定该学院不是物理上消失）并可用于其他 事情，但是Course 对象在学院之外则毫无用 处，它是由学院提供的。

### 注释
类图中另一个共同元素是注释，由具有 狗耳角的方框表示，通过虚线连至其他图符。 它可包含任意内容（文字和图形），类似于编程语言中的注释。（如图A1-3Course）
它可能包括有关类的作用的解释信息或是该类的所有对象应遵守的约束。 如果内容是约束，内容外面将括着大括号



# 部署图 

UML 部署图关注软件系统的结构，用于显示软件系统在硬件平台和运行环境中的物理分布。



例如，设想你正在开发一个基于Web 的图形显示包，包的用户将使用他们的Web 浏 览器访问你的网站，得到渲染信息。你的网站应根据用户的描述渲染图像并将其返回给用户。

因为图像渲染需要大量的计算，所以你决定将渲染从Web 服务器中分离出来，放在一 个单独的平台上。这样，系统涉及三个硬件设备：Web 客户端（运行浏览器的用户计算机）， Web 服务器所在的计算机和渲染引擎所在的计算机。



图 A1-4 显示了此包的部署图。在此图中，硬件部件放在标有“device”的方框中，硬 件部件之间的通信路径用带有可选标签的线表示。在图A1-4 中，路径是用连接设备的通信协议和网络类型标记的。

![图 A1-4 部署图](https://img-blog.csdnimg.cn/20200531152758321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70)

部署图中的每个节点也用设备的细节注释。例如，在图A1-4 中，浏览器客户端被描述 为由Web 浏览器软件构成的人造制品。

> 人造制品：品是指包含在设备上所运行软件的文件

你也可以描述标记值，就像图A1-4 中的Web 服务器节点一样。这些值定义了服务器所采用的 Web 服务器厂家和服务器所使用的操作系统。 



部署图也可以显示运行环境节点，将运行环境节点绘制为包含标签“execution environment”的方框。这些节点表示可以运行其他软件，如操作系统。



# 用例图

用例和 UML 用例图可帮助你从用户的角度决定软件的功能和特点。

为了让读者了解用例和用例图是如何工作的，以下为在线数字音乐商店管理软件创建一些用例和用例图。软件可能要做的一些事情包括： 

- 下载 MP3 音乐文件，并将其存储于应用的存储库中。
- 捕捉流媒体音乐，并将其存储于应用的存储库中。
- 管理应用存储库（例如，删除歌曲或将其添加到播放列表中）。
- 将存储库中的歌曲清单刻录到 CD 上。
- 将存储库中的歌曲清单加载到 iPod 或 MP3 播放器。
- 将一首歌曲从 MP3 格式转换为 AAC 格式，反之亦然。 

这并不是一个全面的列表，但它已足够使你理解用例和用例图的作用。



用例通过定义实现明确目标所需的步骤描述了用户和系统之间的交互（例如，将歌曲清 单刻录到CD 上）。一系列步骤的变动描述了各种不同的场景（例如，如果歌曲清单中的所 有歌曲不适合放在一张 CD 上该怎么办）。 



## 表示

UML 用例图是所有用例和用例之间关系的视图。它提供了系统功能的整体图示。数码音乐应用的用例图如图 A1-5 所示。 

![图 A1-5 音乐系统的用例图](https://img-blog.csdnimg.cn/20200531153709685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70)

在这个图中，木棍小人表示和其他类型的用户（或其他交互元素）相关联的**参与者**。

复杂的系统通常不止一个参与者。例如，自动售货机应用系统可有三个参与者，表示客户、维修人员和装货人员。 



在用例图中，用例用椭圆形显示。角色通过线连接到所执行的用例上。注意，图中并不 包括用例的细节，用例的详细信息需要单独存储。

另外，还需要注意，可将用例放在矩形框 中，而不能将角色放在矩形框中。矩形框表示的是系统的边界，而角色在系统之外。 



## 包含关系

系统的一些用例会互相关联，例如，将歌曲清单刻录到CD 和将歌曲清单存储到iPod 或智能手机具有相似的步骤。为避免用例中的重复，需建立新用例来表示重复活动，然后让其他用例 包含这个新用例，作为其他用例的一个步骤。

在用例图中，如图A1-6 所示，这种包含关系用标有 include 的虚线箭头来连接用例和被包含的用例。 



![图 A1-6 具有包含用例的用例图](https://img-blog.csdnimg.cn/20200531154102846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70)

由于用例图显示了所有的用例，因此，用例图有助于确保覆盖系统的所有功能。

在我们 的数码音乐系统中，确实需要更多的用例，如播放库中歌曲的用例。但是请记住，用例在软件开发过程中最有价值的地方是对每个用例的文字说明，而不是总体用例图[Fow04]。通过用例的说明，才能对所开发系统的目标形成清晰的理解。



# 顺序图

类图和部署图显示系统构件的静态结构，而顺序图显示任务执行过程中对象之间的动态通信。它显示了完成任务的对象之间消息发出的先后顺序。顺序图可以显示某个用例或软件系统的某个场景中存在的交互



## 表示

在图 A1-7 中，可以看到一个画图程序的顺序图。

该图显示了在一幅图中点击一个图形时高亮度显示所涉及的步骤。图顶端行中的每个方框通常对应一个对象，虽然方框也有可
能模拟其他东西，比如类。

- 如果方框表示对象（如我们所有例子中的情况），那么在方框内，我们可以有选择地规定冒号前的对象名。也可在冒号之后写上类名，如图 A1-7 中第三个方框所示。

- 在每个方框下面都有一条被称为对象生命线的虚线。顺序图中的垂直轴代表着时间，随着时间逐渐增加，线条逐渐向下移动。

![图 A1-7 一个顺序图的例子](https://img-blog.csdnimg.cn/2020053115465777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70)

- 顺序图使用从调用者到被调用者的水平箭头来表示方法调用，箭头上标有方法名称，可选部分包括参数、参数的类型和返回类型。

  如图 A1-7 所示，MouseListener 调用 Drawing 的 getFigureAt() 方法。

- 当对象在执行方法时（即在堆栈里有活动帧时），在对象的生命线下面可选择性地显示一条空白的条，称为活动条。

  在图 A1-7 中，对于所有方法的调用都绘制了活动条。

- 图也可以通过虚线箭头和可选标记选择性地显示方法调用的返回结果。

  在图 A1-7 中，getFigureAt() 方法的返回结果由返回对象的名字标记。普遍的做法如图 A1-7 所示，当一个无返回结果的方法被调用时，将不会有返回箭头，因为这样将会使图变得杂乱，而且不会起任何重要作用。

- 有箭头的黑圆圈表明一条来源未知或无关的发现消息。



你现在应该能够理解图 A1-7 显示的任务了。

1. 未知源调用 MouseListener 中的 mouseClicked() 方法， 将点击的点作为参数传入。
2. MouseListener 然后调用 Drawing 的 getFigureAt() 方 法， 并得到返回的一个Figure对象。
3.  接着 MouseListener 调用 Figure 的 highlight() 方法，传递一个 Graphics 对象作为参数作为响应
4. Figure 调用 Graphics 对象的三个方法用红色画出图形。



## 逻辑控制-交互框

图 A1-7 比较简单，不包括附加条件和循环。若需逻辑控制结构，则最好为每种情况都绘制一张单独的顺序图。即当消息根据条件可有两条不同的路径时，则需要绘制两张分开的顺序图，为每种可能性绘制一张。



若想要在一张顺序图上包括循环、条件和其他控制结构，则可以使用交互框。交互框是矩形，包围图的一部分，并用其所表示的控制结构的类型做标记。



图 A1-8 描述了这种情况，高亮显示给定矩形中所有图形所涉及的过程。

![图 A1-8 带两个交互框的顺序图](https://img-blog.csdnimg.cn/20200531155855724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70)

1. 将消息 rectDragged 发送给 MouseListener
2. MouseListener 通知绘图部分高亮显示矩形中的所有图形，具体做法是调用 Drawing 对象的 highlightFiguresIn() 方法，并传递矩形作为参数
   - 此方法要对 Drawing 对象中的所有 Figure 对象进行循环，如果 Figure 和矩形相交，则需要 Figure 高亮显示自身。

在方括号内的短语称为**守卫**，守卫是布尔条件，如果交互框中的动作要继续，则守卫必须为真。

loop是循环，opt是满足条件执行



## 其他特点

顺序图还有很多其他特点。例如：
1.  可清楚地分辨出同步和异步消息。同步消息用实体箭头表示，而异步消息用棒形箭头（stick arrowhead）显示。
2.  可用箭头表示对象向它本身发送消息。所用的箭头需从该对象发出，然后折向下，再指回对象本身。
3.  通过绘制指向对象方框的带有适当标记（例如带有 create 标签）的箭头来表示对象的创建。这种情况下，方框将出现在比行动开始时已存在对象对应的方框低一些的位置。
4.  也可通过对象生命线末端的大写 X 显示对象的销毁。其他对象可以销毁一个对象，在这种情况下，一个箭头从其他对象指向 X。X 通常表示该对象已不再有用，因此可以准备进行垃圾回收。

最后三个特点都显示在图 A1-9 所示的顺序图中。

![图 A1-9 顺序图中的创建、销毁和循环](https://img-blog.csdnimg.cn/20200531160217427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70)

# 通信图

UML 通信图（在 UML  1.x 中称为“协作图”）提供了通信时间顺序的另一种表达形式，**但是强调对象和类之间的关系，而不是时间顺序。**



图A1-10 所示的通信图与图A1-7 中的顺 序图显示的是相同的动作。 



在通信图中相互作用的对象由矩形表示。对象之间的关联由矩形之间连接的线表示。对 于图中启动消息传递序列的对象，通常有传入箭头指向该对象。箭头由数字和消息名称标记。如果传入消息被标记为数字1 并且它使接收对象调用其他对象的其他消息，则这些消息 将沿关联线从发送者到接收者的箭头表示，并按照它们被调用的顺序，标以数字 1.1、1.2 等。 如果这些消息又调用了其他消息，那么另外的十进制小数点和数字将被添加到标记这些消息 的数字中，说明消息传递的进一步嵌套。



![图 A1-10 UML通信图](https://img-blog.csdnimg.cn/20200608114100520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70)

在图A1-10 中，可以看到mouseClicked 消息调用getFigureAt() 方法，然后又调用 highlight() 方法。highlight() 消息调用其他三个消息：setColor()、drawRect() 和 drawstring()。 每个标签上的数码编号就像每条消息的时序性质那样显示嵌套。 



有很多可选特点被添加进箭头标记中。例如，可以在数字前面添加一个字母。传入 箭头可以标记为A1 ：mouseClicked(point)，指明可执行线程A。如果其他消息在其他线 程中执行，那么它们的标记前面将会是一个不同的字母。例如，如果mouseClicked() 在 线程A 中可执行，但是它创建了一个新线程B，并且调用该线程中的highlight()，那么从 MouseListener 到 Figure 的箭头将被标记为 1.B2：highlight(graphics)。 



**如果对显示对象之间的关系及对象间传递的消息感兴趣，那么通信图可能是比顺序图更 好的选择。如果对命令传递的时间顺序感兴趣，那么顺序图也许更好。**



# 活动图

UML 活动图通过系统所执行动作之间的控制流来描述系统或部分系统的动态行为。它 类似于流程图，但活动图可以显示并行流。 



## 动作节点

活动图的主要构件是`动作节点`，由圆角矩形表示，对应于软件系统执行的任务。

从一个 动作节点到另一个动作节点的箭头表示控制流。也就是说，在两个动作节点之间的箭头意味 着第一个动作完成后，第二个动作才开始。

实心黑点表示活动开始的初始节点。被黑圆圈包围的黑点表示活动结束的最终节点。 



## 分叉

`分叉`表示活动分为两个或更多并行活动，被绘制成水平黑条，并带有一个流入箭头和两 个或更多流出箭头。

每个流出箭头都代表一个控制流，此控制流可与其他流出箭头所对应的 控制流并行执行。

这些并行活动可在一台计算机上使用不同的线程执行，甚至使用不同的计算机执行。 



图 A1-11 显示了一个烤蛋糕的样本活动图。第一步是寻找食谱。一旦找到了食谱，就可 以称量和搅拌干原料和湿原料，并且可以预热烤箱。干原料的搅拌可与湿原料的搅拌以及烤 箱的预热并行进行。

![图 A-11 烤蛋糕的UML活动图](https://img-blog.csdnimg.cn/20200608114646471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70)

## 合并

`合并`是同步并行控制流的一种方式。它由水平黑条表示，黑条带有两个或更多的流入箭 头和一个流出箭头。直至所有流入箭头所表示的控制流均已完成，流出箭头表示的控制流才 能执行。在图 A1-11 中，在将干湿原料搅拌在一起的动作之前有一个合并。该合并表明在两 种原料搅拌在一起之前，必须先各自搅拌。图中第二个合并表明，在能够烘制蛋糕之前，所 有的原料必须搅拌到一起，并且烤箱必须处于合适的温度。 



## 判定

`判定`节点与依赖条件的控制流分支相对应。这样的节点用菱形表示，带有一个流入箭头 和两个或更多的流出箭头。每个流出箭头都有守卫标记（括号里的条件）。控制流沿守卫为真的流出箭头方向进行。

有必要确保条件已经覆盖了所有分支，这样使得每次到达决策节点 时，其中都有一个条件为真。

图A1-11 显示了判定节点沿着烘制蛋糕过程的进行状况。如果 蛋糕烤好了，那么将会从烤箱中拿出来。否则，还需再烤一段时间。



## 泳道活动图

图 A1-11 中的活动图并未说明的是谁或什么做了每次的动作。通常没有必要准确地区分 动作的主体。但是，如果想表明动作在参与者中是如何划分的，则可以采用泳道活动图，如 图 A1-12 所示

正如名字所暗示的那样，将图划成条或“道”就形成了泳道，每道都对应一 个参与者。一个泳道内的所有动作都由该泳道对应的参与者完成。

在图 A1-12 中，Jennie 负 责搅拌干原料，然后将干原料与湿原料搅拌到一起，Helen 负责加热烤箱和取出蛋糕，Mary 负责其余的所有事情。

![图 A1-12 增加了泳道的蛋烘制活动图](https://img-blog.csdnimg.cn/20200608114959122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70)



# 状态图

对象在特殊点的即时动作取决于当时的状态，也就是当时变量的值。作为一个小例子， 想想带有布尔实例变量的对象。实施操作时，如果变量为真，则对象可以做某件事，如果变 量为假，则对象可以做其他事情。 



UML 状态图模拟了对象的状态，图中执行的动作取决于这些对象的状态和状态之间的 转换。 



作为例子，考虑Java 编译器的一部分状态图。输入编译器的是文本文件，可以认为文本是长字符串。编译器每次读一个字符，并且根据读入的字符决定程序结构。读字符过程中忽略了“空白”字符（例如，空格、制表、换行和返回字符）以及注释中的字符。 



假定编译器将越过空白和注释字符的任务授权给WhiteSpaceAndCommentEliminator 类。也就是说，该对象的任务是读取输入字符，直到所有空白和注释字符都被读出， 这时它会将控制权转交给编译器去读取和处理非空白和非注释的字符串。

思考一下 WhiteSpaceAndCommentEliminator 对象是怎样读取字符的，并判断下一字符是否为空白或注释。

对象可通过测试下一字符的“”、“\t”、“ \n”和“ \r”来检查空白字符。但 对象如何判断下一字符为注释的一部分呢？

举个例子，当它第一次看到“/”时，并 不知道该字符是表示除法操作符还是/= 操作符的一部分，或者是行注释或块注释的开 始。为了做出决定，WhiteSpaceAndCommentEliminator 需要记住这样的事实：即它看到 了一个“/”，然后移动到下一字符。如果“/”后的字符为另一个“/”或者“*”，那么 WhiteSpaceAndCommentEliminator 就会知道它正在读取注释，能直接到达注释末端而不用 处理或保存任何字符。

如果第一个“/”后的字符是除了“/”和“ *”的任意字符，那么 WhiteSpaceAndCommentEliminator 就会知道“/”表示除法操作或/= 操作的一部分，它就 会停止向前检查字符。 



总之，WhiteSpaceAndCommentEliminator 在读取字符的同时，还需要追踪几个事件

- 当前字符是否为空白字符
- 前面读取的字符是否为“/”
- 正在读取的字符是否为注释，
- 是否到达了注释的末端等

这些分别对应WhiteSpaceAndCommentEliminator 对象的不同状 态。在每个状态中，WhiteSpaceAndCommentEliminator 对读入的下一字符采取不同的行为。



![图 A1-13 Java中越过空白和注释的状态图](https://img-blog.csdnimg.cn/20200608115717325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70)

为了帮助观察对象的所有状态以及状态的改变，可以利用图A1-13 所示的UML 状态图。

## 组成

状态图通过圆角矩形表示状态，每个矩形的上半部分有它的名字。

状态图中还有 一个称为“初始伪态”的黑色圆圈，它并不真正表示一个状态，只是指向初始状态。在 图 A1-13 中，start 状态即为初始状态。

从一个状态指向另一个状态的箭头表明对象状 态之间的转换或改变。每个**转换由一个触发事件、一个斜杠（/）和一项活动**标记。转换标记的所有部分在状态图里是可选的。

如果对象正处于某一状态，它的一个转换的触发事件发生了，则执行转换活动，对象将呈现由转换所确定的新状态。

例如，在图A1-13 中，如果WhiteSpaceAndCommentEliminator 对象处于start 状态，并且下一字符为“/”， 那么WhiteSpaceAndCommentEliminator 将越过该字符并且转换为saw‘ /’状态。如 果“ /”之后的字符是另一个“/”，那么对象将前进到line comment 状态并将一直停留在 该状态，直至读到行末尾的字符。如果“/”后的下一字符是“*”，那么对象将前进到 block comment 状态，并一直停留在该状态直到看见另一个“*”，后面跟有一个“/”，这 表明块注释的结束。研究此图，确保你已经理解了。

注意，当前进到空白字符或注释时， WhiteSpaceAndCommentEliminator 返回到start 状态并从头开始。这个动作是必需的，因为 在 Java 源代码中，任意字符之前都可能有几段连续的注释和空白字符。



对象可以转换到最终状态，通过用白色圆圈里的黑色圆圈来表示最终状态，这表明 没有任何转换了。

在图A1-13 中，下一字符不是空白或注释的一部分时，WhiteSpaceAnd CommentEliminator 对象结束。

注意，所有的转换中除了两个指向最终状态的转换之外都有 包括前进到下一字符的活动。这两个指向最终状态的转换不可以前进到下一字符，因为下一 字符是编译器感兴趣的单词或符号的一部分。

注意，如果对象处于saw‘ /’状态，但下一 字符不是“/”或“*”，那么“/”是一个除法操作或 /= 操作的一部分，因此我们不想前进。 实际上，我们更希望后退一个字符，使得“/”成为下一字符，这样“/”可以被编译器使用。 在图 A1-13 中，后退活动被标记为 pushback‘/’。



状态图有助于发现遗漏或意外情况。也就是说，使用状态图易于保证对于所有可能的状 态，已经考虑了所有可能的触发事件。例如，在图A1-13 中，很容易验证每一状态均包括所 有可能字符的转换。 



## 活动状态

UML 状态图还包括许多图A1-13 不具有的其他特性。例如，当对象处于某一状态时， 它通常不做任何事情，只是等待触发事件的发生。

然而，也存在一种特殊状态，称为`活动状态`，在这种状态下，对象执行某些活动，称为do-activity。要表明一种状态是状态图中的 活动状态，将短语“do/”添加进状态圆角矩形的下半部分，短语“do/”的后面跟有该状 态下将要完成的活动。

由于在转换发生时触发事件是可选的，因此就可能出现转换的标记中没有触发事件的情 况。这种情况下，对于正常的等待状态，对象会立即从该状态转换到新状态。对于活动状 态，这样的转换在 do-activity 完成后立即进行。



![图 A1-14 具有活动状态和无触发状态转换的状态图](https://img-blog.csdnimg.cn/20200608121330509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MzY5NA==,size_16,color_FFFFFF,t_70)

图 A1-14 通过商业电话的状态描述了这种情况。当呼叫者处于等待状态时，呼叫进入播 放音乐等待状态（舒缓的音乐将会播放 10 秒钟）。 10 秒之后，该状态的 do-activity 完成，状态行为如同正常的不活动状态。

如果呼叫者在播放音乐等待状态下按下“#”键，则来电转 换至取消状态，接着立即转换至拨号音状态。如果“#”键在10 秒钟音乐播放完之前就被 按下，则 do-activity 中断，音乐也会立即停止。



# 对象约束语言概述

UML 的多种图为设计模型提供了一套丰富的表达方式。然而，图形表达通常是不够的， 需要明确和正式的表示信息的机制来约束设计模型的元素。

当然，可能会使用自然语言（如 英语）来描述约束，但是，这种方法必定导致不一致性和歧义性。因此，一种更为形式化的 语言——借鉴集合论和形式化规格说明语言但具有编程语言的少量数学语法——似乎是恰当的。 



对象约束语言（Object Constrain Language，OCL）是对UML 的补充，方法是允许使用形式语法和语义构造有关不同设计模型元素（例如，类和对象、事件、消息、接口）的 无歧义语句。

最简单的OCL 语句由以下4 部分构造：

1. 语境：定义语句有效的限制情况； 
2. 特性：表示语境的某些特点（例如，如果语境是类，特性可能是属性）；
3. 操作：操纵或取得特性的操作（例如，面向算术，面向集合）；
4. 关键词：（例如，if、then、else、and、or、 not、implies）是用来具体说明条件表达式的。 

举个简单的OCL 表达式的例子：

- 自然语言：表明只有在顾客同意了工作成本时才进行授权。

- 在 OCL 中，表达式可采取如下形式： 

  ```OCL
  customer
  	self.authorizationAuthority = 'yes'
  ```

  其中，Customer 类（实际上是类的一个具体实例）的布尔属性authorizationAuthority 对于需要满足的守卫条件必须设为“yes”。 



当创建了设计模型时，通常有这样一些实例，在这些实例中，设计说明的一些动作完成 之前，前置条件和后置条件必须得到满足。

OCL 提供了强大的工具，以形式化的方式说明前置条件和后置条件。

举个例子，考虑影印中心系统，顾客为印刷工作提供了成本上限，同时，当指定了其他印刷工作特性时，客户提供 “下拉式”交付日期。如果成本和交付估计超过了这些界限，该工作将不会提交，并且客户一定要得到通知。

在 OCL 中，可以用下面的方式来描述前置条件和后置条件： 

```OCL
context PrintJob::validate(upperCostBound : Integer, custDeliveryReq : Integer)
	pre: upperCostBound > 0
 		and custDeliveryReq > 07
 		and self.jobAuthorization = ‘no’
 	post: if self.totalJobCost <= upperCostBound and self.deliveryDate <= custDeliveryReq
 		then
 			self.jobAuthorization = ‘yes’
 		endif 
```

OCL 语句定义了一个不变式（inv）——某些行为之前（pre）和之后（post）必须存在的条件。

一开始，要建立前置条件，客户必须说明有限制的成本和交付日期，并且授权也必须 设置为“no”。

在成本和交付确定之后，就可以应用后置条件了。也应该注意到，这里的表达式 `self.jobAuthorization = 'yes' `不是将值设置为“yes”而是声明 jobAuthorization 必须在操作结束时被设置成“yes”。 

